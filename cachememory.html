<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache Memory Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f4f4f4;
        }

        #simulation-controls {
            margin-bottom: 20px;
        }

        #output {
			position: relative;
            display: none;
            height: 350px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
			width: 50%;
        }

		#memory-values {
            display: block;
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
            width: 50%;
        }

        .cache-set {
            margin-bottom: 5px;
            margin-right: 10px;
            border: 1px solid #ccc;
            padding: 10px;
            text-align: center;
        }

        .memory {
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }

        button {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
        }

        button:hover {
            background-color: #45a049;
        }
		
		#nextbutton {
			display: none;
			margin-top: 15px;
			margin-left: 740px;
		}
		
		nextbutton {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
        }

        nextbutton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>

<div id="simulation-controls">
    <label for="memoryBlocks" id="memoryBlocksLabel">Memory Blocks:</label>
    <input type="number" id="memoryBlocks" value="32">

    <label for="test-case">Select Test Case:</label>
    <select id="test-case">
        <option value="1">Sequential blocks</option>
        <option value="2">Random blocks</option>
        <option value="3">Mid-repeat blocks</option>
		<option value="4">Manual Input blocks</option>
    </select>

    <label>
        <input type="checkbox" id="show-each-step" checked>
        Show each step
    </label>
    <button id="simulateCache">Simulate Cache Process</button>
</div>

<div id="memory-values">
    <textarea id="memory-input" placeholder="Enter comma-separated memory values" style="width: 99%; height: 190px; resize: none;"></textarea>
</div>
<div id="output"></div>
<button id="nextbutton">Next</button>


<script>
    const SETS = 4;
    const BLOCKS_PER_SET = 8;
    const WORDS_PER_BLOCK = 64;
    const EMPTY = '';
    const CACHE_ACCESS_TIME = 1;
    const MEM_ACCESS_TIME = 10;

	document.getElementById('test-case').addEventListener('change', function() {
		const testCase = this.value;
		const memoryBlocksLabel = document.getElementById('memoryBlocksLabel');
		const memoryBlocksField = document.getElementById('memoryBlocks');
		const memoryInputField = document.getElementById('memory-input');

		if (testCase === '3') {
			memoryBlocksLabel.textContent = 'Cache Blocks:';
		} else {
			memoryBlocksLabel.textContent = 'Memory Blocks:';
		}
		
		if (testCase === '4') {
			memoryInputField.disabled = false;
			memoryBlocksField.disabled = true;
		} else {
			memoryInputField.disabled = true;
			memoryBlocksField.disabled = false;
		}
	});
	
    document.getElementById('simulateCache').addEventListener('click', async () => {
		const memoryBlocks = document.getElementById('memoryBlocks').value;
		const testCase = document.getElementById('test-case').value;
		const showEachStep = document.getElementById('show-each-step').checked;
		let memoryInput = document.getElementById('memory-input');

		let memory;
		if (testCase === '4') {
			memory = memoryInput.value.split(',').map(Number);
		} else {
			memory = generateMemory(testCase, memoryBlocks);
		}

		const cache = Array.from({ length: SETS }, () => Array(BLOCKS_PER_SET).fill(EMPTY));
		const lruStack = Array.from({ length: SETS }, () => []);

		let outputElement = document.getElementById('output');
		outputElement.style.display = 'block';
		outputElement.innerHTML = '<strong>Output:</strong><br>';

		let logContent = await simulateCacheProcess(memory, cache, lruStack, showEachStep, outputElement);
		generateDownload(logContent, 'Caching Log.txt');
	});
	
	document.getElementById('memory-input').addEventListener('input', function(event) {
		const memoryInput = event.target.value.trim();
		const memoryBlocksField = document.getElementById('memoryBlocks');

		if (memoryInput.length > 0) {
			memoryBlocksField.disabled = true;
		} else {
			memoryBlocksField.disabled = false;
		}
	
		const memoryValues = event.target.value.split(',').map(val => val.trim());
		document.getElementById('memoryBlocks').value = memoryValues.length;
	});
	
	document.addEventListener('DOMContentLoaded', function() {
		document.getElementById('memory-input').addEventListener('input', function(event) {
			this.value = this.value.replace(/[^0-9,]/g, '').replace(/,,+/g, ',');
		});

		document.getElementById('memoryBlocks').addEventListener('input', function(event) {
			this.value = this.value.replace(/[^0-9]/g, '');
		});
		
		document.getElementById('memory-input').disabled = true;
	});

    function generateMemory(testCase, memoryBlocks) {
        let memory = [];
        const cachesize = BLOCKS_PER_SET * SETS;
        
        switch (testCase) {
			case '1':
                for (let i = 0; i < memoryBlocks; i++) {
                    memory.push(i);
                }
                for (let j = 0; j < 3; j++) {
                    memory.push(...memory.slice(0, memoryBlocks));
                }
                break;
            case '2':
                const randrange = WORDS_PER_BLOCK;
                for (let i = 0; i < memoryBlocks * 4; i++) {
                    memory.push(Math.floor(Math.random() * randrange));
                }
                break;
			case '3':
					let sequence = [];
				for (let i = 0; i < memoryBlocks - 1; i++) {
					sequence.push(i);
				}
				for (let i = 1; i < memoryBlocks; i++) {
					sequence.push(i);
				}
				for (let i = memoryBlocks; i < 2 * memoryBlocks; i++) {
					sequence.push(i);
				}
				for (let i = 0; i < 4; i++) {
					memory.push(...sequence);
				}
				break;
        }

        document.getElementById('memory-input').value = memory.join(',');
		return memory;
    }

    async function simulateCacheProcess(memory, cache, lruStack, showEachStep, outputElement) {
        let hits = 0, misses = 0;
        let logContent = [];

        for (let index = 0; index < memory.length; index++) {
            let val = memory[index];
            let cacheSet;
            let isHit = cache.some(cset => cset.includes(val));
            let blockNum;

            if (isHit) {
                hits++;
                cacheSet = cache.findIndex(cset => cset.includes(val));
                blockNum = cache[cacheSet].indexOf(val);
                lruStack[cacheSet].splice(lruStack[cacheSet].indexOf(val), 1);
                lruStack[cacheSet].push(val);

                logContent.push(`Value ${val} is present in set ${cacheSet} block ${blockNum}`);
            } else {
                misses++;
				cacheSet = index % SETS;
				logContent.push(`Value ${val} is not present in cache...`);
				logContent.push(`Index ${index} with value ${val} going to set ${cacheSet}`);
				
                if (cache[cacheSet].includes(EMPTY)) {
                    blockNum = cache[cacheSet].indexOf(EMPTY);
					
                    logContent.push("Set is not full");
                } else {
                    let lruVal = lruStack[cacheSet][0];
                    lruStack[cacheSet].shift();
                    blockNum = cache[cacheSet].indexOf(lruVal);

                    logContent.push("Set is full therefore LRU");
                }

                cache[cacheSet][blockNum] = val;
                lruStack[cacheSet].push(val);

                logContent.push(`Value ${val} placed in set ${cacheSet} block ${blockNum}`);
            }

            if (showEachStep) {
				updateOutput(cache, index, hits, misses, memory[index], outputElement);
				await next();
			}
			if (!showEachStep) {
				document.getElementById('nextbutton').style.display = 'none';
			}
            
            logContent.push(`Step ${index}: Memory value ${val}, Hits: ${hits}, Misses: ${misses}`);
        }

        displayFinalOutput(cache, hits, misses, memory.length, outputElement);
		
		cache.forEach((set, index) => {
            logContent.push(`Set ${index}: ${set.join(', ')}`);
        });

        const memAccess = memory.length;
        const avgAccessTime = ((hits * CACHE_ACCESS_TIME + misses * (1 + MEM_ACCESS_TIME)) / memAccess).toFixed(2);
        const totalAccessTime = (hits * WORDS_PER_BLOCK * CACHE_ACCESS_TIME) + misses * (1+(WORDS_PER_BLOCK*MEM_ACCESS_TIME));

        logContent.push(`Memory Access Count = ${memAccess}`);
        logContent.push(`${hits} hits, ${misses} misses`);
        logContent.push(`Hit Rate = ${hits}/${memAccess}, Miss Rate = ${misses}/${memAccess}`);
        logContent.push(`Average Memory Access Time = ${avgAccessTime} ns`);
        logContent.push(`Total Memory Access Time = ${totalAccessTime} ns`);

        return logContent.join('\n');
    }
	
	function next() {
        return new Promise(resolve => {
            const nextButton = document.getElementById('nextbutton');
            nextButton.style.display = 'block';
            nextButton.onclick = () => {
                nextButton.style.display = 'none';
                document.getElementById('output').innerHTML = ''; // Clear output box
                resolve();
            };
        });
    }

    function updateOutput(cache, index, hits, misses, memoryValue, outputElement) {
		let stepOutput = `<br><div class="cache-state"><strong>Index ${index}, Memory Value: ${memoryValue}:</strong>`;
		cache.forEach((set, setIndex) => {
			stepOutput += `<div class="cache-set">Set ${setIndex}: ` + set.join(', ') + '</div>';
		});
		stepOutput += `<div> Hits: ${hits}, Misses: ${misses} </div></div>`;
		outputElement.innerHTML += stepOutput;
	}

    function displayFinalOutput(cache, hits, misses, memAccesses, outputElement) {
        let finalOutput = '<br><div class="cache-state"><strong>Final Cache State:</strong><br>';
        cache.forEach((set, index) => {
            finalOutput += `<div class="cache-set">Set ${index}: ` + set.join(', ') + '</div>';
        });
        finalOutput += '</div>';

        const avgAccessTime = ((hits * CACHE_ACCESS_TIME + misses * (1 + MEM_ACCESS_TIME)) / memAccesses).toFixed(2);
        const totalAccessTime = (hits * WORDS_PER_BLOCK * CACHE_ACCESS_TIME) + misses * (1+(WORDS_PER_BLOCK*MEM_ACCESS_TIME));

        finalOutput += `<strong>Final Statistics:</strong><br> 
                        Memory Access Count = ${memAccesses}<br>
                        Hits: ${hits}, Misses: ${misses}<br>
                        Hit Rate = ${hits}/${memAccesses}, Miss Rate = ${misses}/${memAccesses}<br>
                        Average Access Time: ${avgAccessTime} ns<br> 
                        Total Access Time: ${totalAccessTime} ns<br>`;
        outputElement.innerHTML += finalOutput;
		
		document.getElementById('nextbutton').style.display = 'none';
    }

    function generateDownload(text, filename) {
        const element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }
</script>

</body>
</html>
